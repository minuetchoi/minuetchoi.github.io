---
layout: post
title: "[Oracle] 18. SQL - hierachy listAgg function모방"
date: 2022-02-20 12:00:00 +0900
category: oracle
---

# 1. ListAgg함수를 모방

wmsys.wm_concat함수에서 키를 연결하는 행의 문자열을 정리하는 SQL를 모방해보자

### MainTable

| id | name |
| :--- | :--- |
| 1 | Mike |
| 2 | Jane | 
| 3 | Greg |


### SubTable

| id | val |
| :--- | :--- |
| 1 | AAA |
| 1 | CCC |
| 2 | EEE |
| 2 | GGG |
| 2 | III |
| 3 | KKK |
| 4 | BBB |
| 4 | DDD |

```sql
select a.id,
       a.name,
       wm_concat(b.val) as concatVal
from   MainTable a, SubTable b
where  a.id = b.id
group by a.id, a.name;
```

### 출력결과

| id | name | concatVal |
| :--- | :--- | :--- |
| 1 | Mike | AAA,CCC |
| 2 | Jane | EEE,III,GGG |
| 3 | Greg | KKK |


위와 같은 결과로, 

내부결합을 하고나서 분석함수 row_number 함수를 사용해 행번호를 

부여하고, 계층조회를 할때 connect_by_isleaf = 1로 설정해보자

```sql
select id,
       name,
       substr(sys_connect_by_path(val, ','), 2) as concatVal
from   
       (
       select a.id,
           a.name,
           b.val,
           row_number() over(partition by a.id order by b.val) as rn
       from   MainTable a, SubTable b
       where  a.id = b.id
       )
where  connect_by_isleaf = 1
start with rn = 1
connect by prior id = id
and    prior rn = rn - 1
```


connect_by_isleaf는 oracle10g R1 이하는 사용할 수 없으므로, oracle 9i라도 사용할 수 있는 sql를 2가지 소개한다.

### case1

```sql
select id,
       name,
       substr(sys_connect_by_path(val, ','), 2) as concatVal
from   
       (
       select a.id,
           a.name,
           b.val,
           row_number() over(partition by a.id order by b.val) as rn,
           count(*) over(partition by a.id) as maxLevel
       from   MainTable a, SubTable b
       where  a.id = b.id
       )
where  level = maxLevel
start with rn = 1
connect by prior id = id
and    prior rn = rn - 1
```

```sql
select id,
       name,
       max(substr(sys_connect_by_path(val, ','), 2)) as concatVal
from   
       (
       select a.id,
           a.name,
           b.val,
           row_number() over(partition by a.id order by b.val) as rn
       from   MainTable a, SubTable b
       where  a.id = b.id
       )
start with rn = 1
connect by prior id = id
and    prior rn = rn - 1
group by id, name;
```

# 3. 의존 오브젝트 추적

all_dependencies 데이터사전뷰를 참고하면, 오브젝트간 직접의존성을 알 수 있다.

all_dependencies 데이터사전뷰에 대한 계층조회를 사용해서, 간접의존성까지 조사해보자

### DDL문

```sql
create table TableA as select 1 as colA from dual;
create or replace view VB as select * from TableA;
create or replace view VC as select * from VB;
create or replace view VD as select * from VC;
create or replace view VE as select * from VC;

create or replace view VF as 
select * from VD union all
select * from VE;
```

![alt text](/public/img/sql_01.gif)

TableA에 직접의존하는 오브젝트와 간접의존하는 오브젝트를 조회해 보자

```sql
select referenced_owner || '.' || referenced_name as regObj,
       type,
       owner || '.' || name as object,
       decode(level, 1, '직접', '간접') as "의존",
       substr(sys_connect_by_path(referenced_name, '←'), 2) || '←' || name as "의존리스트"
from   all_dependencies
start  with referenced_name = upper('TableA')
connect by  prior owner = referenced_owner
       and  prior name  = referenced_name
       and  prior type  = referenced_type
order  siblings by owner, name, type;
```

### 출력결과

| refObj | type | object | 의존 | 의존리스트 |
| :---: | :---: | :---: | :---: | :---: |
| TEST.TABLEA | VIEW | TEST.VB | 직접 | TABLEA←VB |
| TEST.VB | VIEW | TEST.VC | 간접 | TABLEA←VB←VC |
| TEST.VC | VIEW | TEST.VD | 간접 | TABLEA←VB←VC←VD |
| TEST.VD | VIEW | TEST.VF | 간접 | TABLEA←VB←VC←VD←VF |
| TEST.VC | VIEW | TEST.VE | 간접 | TABLEA←VB←VC←VE |
| TEST.VE | VIEW | TEST.VF | 간접 | TABLEA←VB←VC←VE←VF |

상하위조건이 복수일 경우, 아래와 같이 복수열비교를 할 수 있다.

```sql
select referenced_owner || '.' || referenced_name as regObj,
       type,
       owner || '.' || name as object,
       decode(level, 1, '직접', '간접') as "의존",
       substr(sys_connect_by_path(referenced_name, '←'), 2) || '←' || name as "의존리스트"
from   all_dependencies
start  with referenced_name = upper('TableA')
connect  by (prior owner, prior name, prior type) 
        =  ((referenced_owner, referenced_name, referenced_type))
order  siblings by owner, name, type;
```